// @flow

import React from 'react';
import Relay from 'react-relay';
import moment from 'moment';
import { compose, lifecycle, withProps, withPropsOnChange, withState } from 'recompose';
import { insertRule } from 'glamor';
import * as d3 from 'd3';
import { startCase } from 'lodash';
import Lolliplot from '@oncojs/react-lolliplot';
import withRouter from '@ncigdc/utils/withRouter';
import groupByType from '@ncigdc/utils/groupByType';
import { buildProteinLolliplotData } from '@ncigdc/utils/data';
import { withTooltip } from '@ncigdc/uikit/Tooltip';
import { Row, Column } from '@ncigdc/uikit/Flex';
import DropdownItem from '@ncigdc/uikit/DropdownItem';
import Dropdown from '@ncigdc/uikit/Dropdown';
import Spinner from '@ncigdc/uikit/Loaders/Material';
import Button from '@ncigdc/uikit/Button';
import { visualizingButton } from '@ncigdc/theme/mixins';
import DoubleHelix from '@ncigdc/theme/icons/DoubleHelix';
import DownloadVisualizationButton from '@ncigdc/components/DownloadVisualizationButton';
import Loader from '@ncigdc/uikit/Loaders/Loader';
import wrapSvg from '@ncigdc/utils/wrapSvg';

const id = 'protein-viewer-root';
const selector = `#${id}`;

insertRule(`
  [class^="mutation-circle"] { cursor: pointer; }
`);

const styles = {
  heading: {
    flexGrow: 1,
    fontSize: '2.2rem',
    marginBottom: 7,
    marginTop: 7,
    display: 'flex',
    alignItems: 'center',
  },
};

type TTranscript = {
  length_amino_acid: number,
  is_canonical: boolean,
  transcript_id: string,
};

type TProps = {
  ssms: {
    hits: {
      edges: Array<{
        node: {},
      }>,
    },
  },
  state: {
    activeTranscript: TTranscript,
    actions: {
      reset: Function,
    },
  },
  viewer: {
    node: {
      transcripts: {
        hits: {
          edges: Array<{
            node: TTranscript,
          }>,
        },
      },
    },
  },
  setState: Function,
  setTooltip: Function,
  push: Function,
  geneId: String,
  relay: Object,
  mutationId: string,
};

let container;

const LolliplotComponent = compose(
  withTooltip,
  withRouter,
  withState('state', 'setState', {
    activeTranscript: {},
    min: 0,
    max: 500,
    width: 0,
    blacklist: 'consequence',
    consequenceBlacklist: new Set(),
    impactBlacklist: new Set(),
    ssmsLoading: false,
  }),
  withProps(({ state, setState }) => ({
    fetchSsms(props: Object): void {
      const transcript = props.state.activeTranscript.transcript_id
        ? props.state.activeTranscript
        : (props.viewer.node.transcripts.hits.edges.find(x => x.node.is_canonical) || {}).node;

      props.relay.setVariables({ // eslint-disable-line fp/no-this
        fetchSsms: true,
        filters: {
          op: 'AND',
          content: [
            {
              op: '=',
              content: {
                field: 'consequence.transcript.transcript_id',
                value: [transcript.transcript_id],
              },
            },
            {
              op: 'NOT',
              content: {
                field: 'consequence.transcript.aa_start',
                value: 'MISSING',
              },
            },
          ],
        },
      }, ({ done }) => {
        if (!props.state.ssmsLoading && !done) {
          props.setState(s => ({ ...s, ssmsLoading: true }));
        }

        if (done) {
          props.setState(s => ({ ...s, ssmsLoading: false }));
        }
      });
    },
    fetchGene(props: Object): void {
      props.relay.setVariables({ // eslint-disable-line fp/no-this
        fetchGene: true,
        lolliplotGeneId: btoa(`Gene:${props.geneId}`), // eslint-disable-line fp/no-this
      });
    },
    toggleBlacklistItem: variant => {
      const blacklist = new Set(state[`${state.blacklist}Blacklist`]);
      if (blacklist.has(variant)) {
        blacklist.delete(variant);
      } else {
        blacklist.add(variant);
      }
      setState(s => ({ ...s, [`${state.blacklist}Blacklist`]: blacklist }));
    },
  })),
  lifecycle({
    componentDidMount(): void {
      this.props.fetchGene(this.props);
      window.addEventListener('resize', () => {
        this.props.setState(s => ({ ...s, width: container.clientWidth }));
      });
    },
    async componentWillReceiveProps(nextProps: TProps): Promise<*> {
      /*
        scenario a)

        first time around nothing has been fetched

        scenario b)

        component receives new data (ex. quicksearch transition, transcript selection)
        both gene and ssm may have been loaded into relay props already

        ~~~

        in both cases, gene will be fetched before ssms

      */

      // if page id changes:

      if (this.props.geneId !== nextProps.geneId) {
        this.props.fetchGene(nextProps);
        return;
      }

      // no gene yet

      if (!nextProps.viewer.node) {
        return;
      }

      // gene returned, display plot

      if (!this.props.viewer.node && nextProps.viewer.node) {
        const activeTranscript =
          (nextProps.viewer.node.transcripts.hits.edges.find(x => x.node.is_canonical) || {}).node;

        this.props.setState(s => ({
          ...s,
          activeTranscript,
          min: 0,
          max: activeTranscript.length_amino_acid,
        }));
      }

      // if the gene changed

      if (this.props.viewer.node) {
        const pt = (this.props.viewer.node.transcripts.hits.edges.find(x => x.node.is_canonical) || {}).node;
        const nt = (nextProps.viewer.node.transcripts.hits.edges.find(x => x.node.is_canonical) || {}).node;

        if (pt.transcript_id !== nt.transcript_id) {
          const activeTranscript =
            (nextProps.viewer.node.transcripts.hits.edges.find(x => x.node.is_canonical) || {}).node;

          this.props.setState(s => ({
            ...s,
            activeTranscript,
            min: 0,
            max: activeTranscript.length_amino_acid,
          }));
        }
      }

      // if we have not received ssm data yet, fetchSsms will receive hits.total

      if (!nextProps.ssms.hits) {
        this.props.fetchSsms(nextProps);
        return;
      }

      // if we have ssms but the transcript changed

      if (this.props.state.activeTranscript.transcript_id !== nextProps.state.activeTranscript.transcript_id) {
        this.props.fetchSsms(nextProps);
        return;
      }

      // if we have hits.total set $haveTotal to true to fetch first 5 ssms

      if (!this.props.ssms.hits && nextProps.ssms.hits.total) {
        this.props.relay.setVariables({ haveTotal: true });
        return;
      }

      // edges have not returned yet

      if (!nextProps.ssms.hits.edges) {
        return;
      }

      // edges have returned but there are more mutations to fetch

      if (
        nextProps.ssms.hits.edges.length < this.props.ssms.hits.total &&
        (this.props.ssms.hits.edges || []).length !== nextProps.ssms.hits.edges.length
      ) {
        this.props.relay.setVariables({ first: nextProps.ssms.hits.edges.length + 100 });
      }
    },
  }),
  withPropsOnChange(['state'], ({ state }) => ({
    filterByType: type => d => !state[`${type}Blacklist`].has(d[type]),
  })),
  withPropsOnChange(
    ['viewer', 'ssms', 'state'],
    ({
      state: {
        activeTranscript,
      },
      ssms,
    }) => {
      const lolliplotData = buildProteinLolliplotData({
        transcript: activeTranscript,
        data: ((ssms.hits || {}).edges || []).map(x => x.node),
      });

      return {
        lolliplotData,
      };
    }
  ),
  withPropsOnChange(
    ['lolliplotData'],
    ({
      lolliplotData,
    }) => {
      const consequences = groupByType('consequence', lolliplotData.mutations);

      const highContrastPallet = [
        '#007FAA',
        '#E00000',
        '#9B59B6',
        '#696969',
        '#8D6708',
        '#9F6B3F',
        '#40806A',
        '#DC2A2A',
        '#5A781D',
        '#2574A9',
        '#7462E0',
        '#4B6A88',
        '#856514',
        '#D43900',
      ];

      const mutationColors = {
        consequence: Object.keys(consequences).reduce((acc, type, i) => ({
          ...acc,
          [type]: highContrastPallet[i % highContrastPallet.length],
        }), {}),
        impact: {
          HIGH: 'rgb(221, 60, 60)',
          MODERATE: 'rgb(132, 168, 56)',
          default: 'rgb(135, 145, 150)',
        },
      };

      return {
        mutationColors,
      };
    }
  )
)(({
  state: {
    activeTranscript,
    notEnoughData = false,
    width,
    min,
    max,
    blacklist,
    ssmsLoading,
    ...state
  },
  mutationId,
  toggleBlacklistItem,
  setState,
  viewer: { node: gene },
  ssms,
  setTooltip,
  push,
  lolliplotData,
  mutationColors,
  filterByType,
}) => (
  <Column>
    <Row>
      <h1 style={{ ...styles.heading, padding: '1rem' }} id="protein">
        <DoubleHelix width="12px" />
        <span style={{ marginLeft: '1rem' }}>Protein</span>
      </h1>
    </Row>
    <Loader
      loading={!gene || !lolliplotData.mutations.length}
      height="503px"
    >
      {gene &&
        <Row style={{ marginBottom: '2rem', padding: '0 2rem', alignItems: 'center', height: '35px' }} spacing="1rem">
          <span style={{ alignSelf: 'center' }}>
            Transcript:
          </span>
          <Dropdown
            selected={
              <span
                style={{
                  fontWeight: activeTranscript.transcript_id === gene.canonical_transcript_id
                    ? 'bold' : 'initial',
                }}
              >
                {activeTranscript.transcript_id} ({activeTranscript.length_amino_acid} aa)
              </span>
            }
          >
            {gene.transcripts.hits.edges.map(x => x.node)
              .filter(t => t.transcript_id === gene.canonical_transcript_id)
              .map(t =>
                <DropdownItem
                  key={t.transcript_id}
                  style={{
                    fontWeight: 'bold',
                    ...(activeTranscript.transcript_id === t.transcript_id ? {
                      backgroundColor: 'rgb(44, 136, 170)',
                      color: 'white',
                    } : {}),
                    cursor: 'pointer',
                  }}
                  onClick={() => setState(s => ({ ...s, activeTranscript: t }))}
                >
                  {t.transcript_id} ({t.length_amino_acid} aa)
                </DropdownItem>
            )}
            {gene.transcripts.hits.edges.map(x => x.node)
              .filter(t => t.length_amino_acid && t.transcript_id !== gene.canonical_transcript_id)
              .map(t =>
                <DropdownItem
                  key={t.transcript_id}
                  style={{
                    ...(activeTranscript.transcript_id === t.transcript_id ? {
                      backgroundColor: 'rgb(44, 136, 170)',
                      color: 'white',
                    } : {}),
                    cursor: 'pointer',
                  }}
                  onClick={() => setState(s => ({ ...s, activeTranscript: t }))}
                >
                  {t.transcript_id} ({t.length_amino_acid} aa)
                </DropdownItem>
            )}
          </Dropdown>
          <Button
            style={visualizingButton}
            onClick={() => setState(s => ({ ...s, min: 0, max: activeTranscript.length_amino_acid }))}
            leftIcon={<i className="fa fa-refresh" />}
          >
            Reset
          </Button>
          <DownloadVisualizationButton
            svg={() => wrapSvg({
              selector: `${selector} svg.chart`,
              title: `Gene: ${gene.symbol}, Transcript: ${activeTranscript.transcript_id}(${activeTranscript.length_amino_acid} aa)`,
              margins: { top: 20, right: 20, bottom: 20, left: 20 },
              embed: {
                right: {
                  width: 350,
                  margins: {
                    left: -350,
                  },
                  elements: [
                    document.querySelector('#mutation-stats'),
                  ],
                },
              },
            })}
            data={lolliplotData}
            stylePrefix="#protein-viewer-root"
            slug={`protein_viewer-${gene.symbol}-${moment().format('YYYY-MM-DD')}`}
          />
          {ssmsLoading &&
            <Row style={{ marginLeft: 'auto', alignItems: 'center' }}>
              <div style={{ transform: 'scale(0.6)' }}>
                <Spinner />
              </div>
            </Row>
          }
        </Row>
      }
      {notEnoughData &&
        <Column style={{ alignItems: 'center', padding: '20px' }}>
          Not enough data
        </Column>
      }
      <div style={{ padding: '0 3rem' }} >
        {ssms.hits &&
          <Row>
            <div
              id={id}
              style={{ flex: 1, userSelect: 'none' }}
              ref={
                n => {
                  if (!width) {
                    if (!container) container = n;
                    setState(s => ({ ...s, width: s.width || n.clientWidth }));
                  }
                }
              }
            >
              {width &&
                <Lolliplot
                  d3={d3}
                  min={min}
                  max={max}
                  width={width}
                  data={{
                    ...lolliplotData,
                    mutations: lolliplotData.mutations.filter(d =>
                      d.x > min && d.x < max
                    ).filter(filterByType(blacklist)),
                  }}
                  update={payload => setState(s => ({ ...s, ...payload }))}
                  domainWidth={activeTranscript.length_amino_acid}
                  mutationId={mutationId}
                  onMutationClick={d => { push(`/ssms/${d.id}`); }}
                  getMutationColor={d => mutationColors[blacklist][d[blacklist]]}
                  onMutationMouseover={({ donors = 0, ...d }) => {
                    setTooltip(
                      <span>
                        <div><b>{d.id}</b></div>
                        <div>AA Change: {d.aa_change}</div>
                        <div>DNA Change: {d.genomic_dna_change}</div>
                        <div># of Cases: {donors.toLocaleString()}</div>
                        <div>Functional Impact: {d.impact}</div>
                      </span>
                    );
                  }}
                  onMutationMouseout={() => setTooltip(null)}
                  onProteinMouseover={d => {
                    setTooltip(
                      <span>
                        <div><b>{d.id}</b></div>
                        <div>{d.description}</div>
                        <div><b>Click to zoom</b></div>
                      </span>
                    );
                  }}
                  onProteinMouseout={() => setTooltip(null)}
                />
              }
            </div>
            <div style={{ marginLeft: '20px', width: '250px' }}>
              <div
                style={{
                  border: '1px solid rgb(186, 186, 186)',
                  padding: '13px',
                }}
              >
                <div>
                  <span>
                    Viewing {lolliplotData.mutations.filter(d =>
                      d.x >= min && d.x <= max
                    ).filter(filterByType(blacklist)).length}
                  </span>
                  <span> / </span>
                  <span>{ssms.hits.total} Mutations</span>
                </div>
                <div style={{ marginTop: '6px' }}>
                  <select
                    value={blacklist}
                    onChange={e => {
                      e.persist();
                      setState(s => ({ ...s, blacklist: e.target.value }))
                    }}
                    aria-label="Color by:"
                  >
                    <option value="consequence">Consequence</option>
                    <option value="impact">Impact (VEP)</option>
                  </select>
                </div>
                <div style={{ marginTop: '6px' }}>
                  {Object.entries(groupByType(blacklist, lolliplotData.mutations))
                    .map(([variant, xs]) =>
                      <div
                        key={variant}
                        style={{
                          marginTop: '6px',
                          fontSize: '14px',
                        }}
                      >
                        <Row>
                          <span
                            onClick={() => toggleBlacklistItem(variant)}
                            style={{
                              color: mutationColors[blacklist][variant],
                              textAlign: 'center',
                              border: '2px solid',
                              display: 'inline-block',
                              width: '23px',
                              cursor: 'pointer',
                              marginRight: '6px',
                            }}
                          >
                            {state[`${blacklist}Blacklist`].has(variant)
                              ? <span>&nbsp;</span> : '✓'
                            }
                          </span>
                          <span>{startCase(variant)}:</span>
                          <span style={{ marginLeft: 'auto' }}>
                            <b>
                              {xs.filter(d =>
                                d.x >= min && d.x <= max
                              ).filter(filterByType(blacklist)).length
                              }
                            </b>
                            &nbsp;/ <b>{xs.length}</b>
                          </span>
                        </Row>
                      </div>
                    )
                  }
                </div>
              </div>
            </div>
          </Row>
        }
      </div>
    </Loader>
  </Column>
));

export const LolliplotQuery = {
  initialVariables: {
    fetchSsms: false,
    filters: null,
    score: 'occurrence.case.project.project_id',
    lolliplotGeneId: '',
    fetchGene: false,
    haveTotal: false,
    first: 1000,
  },
  fragments: {
    viewer: () => Relay.QL`
      fragment on Root {
        node(id: $lolliplotGeneId) @include(if: $fetchGene) {
          ...on Gene {
            gene_id
            symbol
            canonical_transcript_id
            transcripts {
              hits(first: 99) {
                edges {
                  node {
                    is_canonical
                    transcript_id
                    length_amino_acid
                    domains {
                      hit_name
                      description
                      start
                      end
                    }
                  }
                }
              }
            }
          }
        }
      }
    `,
    ssms: () => Relay.QL`
      fragment on Ssms {
        dummy_field: hits (first: 1) { total }
        hits(first: $first filters: $filters, score: $score) @include(if: $fetchSsms) {
          total
          edges @include (if: $haveTotal) {
            node {
              score
              ssm_id
              genomic_dna_change
              consequence {
                # a mutation only has one aa_start value per transcript
                # so filter for the one that is currently displayed
                hits(first: 1 filters: $filters) {
                  edges {
                    node {
                      transcript {
                        aa_change
                        aa_start
                        annotation {
                          impact
                        }
                        consequence_type
                        gene {
                          gene_id
                          symbol
                        }
                        is_canonical
                        transcript_id
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    `,
  },
};

export default Relay.createContainer(
  LolliplotComponent,
  LolliplotQuery
);
