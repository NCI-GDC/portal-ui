/* @flow */
import { replaceFilters } from '@ncigdc/utils/filters';
import memoize from 'memoizee';
import { fetchApi } from '@ncigdc/utils/ajax';

const MAX_CASES = 50;
async function getGenes({
  projectId,
  currentFilters,
  consequenceTypes,
  impacts,
}: {
  projectId?: string,
  currentFilters: Object,
  consequenceTypes: Array<string>,
  impacts: Array<string>,
}): Promise<Object> {
  const filters = replaceFilters({
    op: 'and',
    content: [
      projectId && { op: '=', content: { field: 'cases.project.project_id', value: projectId } },
      impacts && { op: 'in', content: { field: 'ssms.consequence.transcript.annotation.impact', value: impacts } },
      consequenceTypes && { op: 'in',
        content: {
          field: 'ssms.consequence.transcript.consequence_type',
          value: consequenceTypes,
        },
      },
    ].filter(Boolean),
  }, currentFilters);

  const fields = [
    'gene_id',
    'case.case_id',
    'symbol',
    'is_cancer_gene_census',
  ];

  return fetchApi(`analysis/top_mutated_genes_by_project?size=50&fields=${fields.join()}${
    filters.content.length ? `&filters=${JSON.stringify(filters)}` : ''
  }`);
}

const OCCURRENCE_CHUNK = 1000;
async function getOccurences(args: {
  projectId?: string,
  geneIds: Array<string>,
  caseIds: Array<string>,
  consequenceTypes: Array<string>,
  impacts: Array<string>,
  currentFilters: Object,
  from?: number,
  hits?: Array<{}>,
}): Promise<Object> {
  const {
    projectId,
    geneIds,
    caseIds,
    consequenceTypes,
    impacts,
    currentFilters,
    from = 0,
    hits = [],
  } = args;

  if (!geneIds.length || !caseIds.length) return { data: { hits } };
  if (from + OCCURRENCE_CHUNK > 10000) {
    console.warn('too many occurrences to fetch');
    return { data: { hits } };
  }

  const filters = replaceFilters({
    op: 'and',
    content: [
      { op: 'in', content: { field: 'genes.gene_id', value: geneIds } },
      { op: 'in', content: { field: 'cases.case_id', value: caseIds } },
      { op: 'in', content: { field: 'ssms.consequence.transcript.annotation.impact', value: impacts } },
      {
        op: 'in',
        content: { field: 'ssms.consequence.transcript.consequence_type', value: consequenceTypes },
      },
      projectId && { op: '=', content: { field: 'cases.project.project_id', value: projectId } },
    ].filter(Boolean),
  }, currentFilters);

  const fields = [
    'ssm.consequence.transcript.consequence_type',
    'ssm.consequence.transcript.annotation.impact',
    'ssm.consequence.transcript.gene.gene_id',
    'ssm.ssm_id',
    'case.case_id',
  ];

  const { data } = await fetchApi(
    'ssm_occurrences',
    {
      headers: { 'Content-Type': 'application/json' },
      body: {
        filters,
        size: OCCURRENCE_CHUNK,
        from,
        fields: fields.join(),
      },
    }
  );

  if (from + OCCURRENCE_CHUNK < data.pagination.total) {
    return getOccurences({ ...args, from: from + OCCURRENCE_CHUNK, hits: [...hits, ...data.hits] });
  }

  return {
    data: {
      hits: [
        ...hits,
        ...data.hits,
      ],
    },
  };
}

async function getCases({
  geneIds,
  projectId,
  currentFilters,
  impacts,
}: {
  geneIds: Array<string>,
  projectId?: string,
  currentFilters: Object,
  impacts: Array<string>,
}): Promise<Object> {
  if (!geneIds.length) return { data: { hits: [] } };

  const filters = replaceFilters({
    op: 'and',
    content: [
      { op: 'in', content: { field: 'genes.gene_id', value: geneIds } },
      { op: 'in', content: { field: 'ssms.consequence.transcript.annotation.impact', value: impacts } },
      projectId && { op: '=', content: { field: 'cases.project.project_id', value: projectId } },
    ].filter(Boolean),
  }, currentFilters);

  return fetchApi('analysis/top_mutated_cases_by_gene', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: {
      filters,
      size: MAX_CASES,
      fields: [
        'diagnoses.days_to_death',
        'diagnoses.age_at_diagnosis',
        'diagnoses.vital_status',
        'demographic.gender',
        'demographic.race',
        'demographic.ethnicity',
        'case_id',
        'summary.data_categories.file_count',
        'summary.data_categories.data_category',
      ].join(),
    },
  });
}

async function getQueries({
  projectId,
  consequenceTypes,
  impacts = ['HIGH'],
  currentFilters,
}: {
  projectId: string,
  consequenceTypes: Array<string>,
  impacts?: Array<string>,
  currentFilters: Object,
}): Promise<Object> {
  const { data } = await getGenes({ projectId, currentFilters, impacts, consequenceTypes });
  const genes = data.hits;
  const geneIds = genes.map(gene => gene.gene_id);

  const cases = await getCases({ projectId, geneIds, currentFilters, impacts });
  const caseIds = cases.data.hits.map(c => c.case_id);
  const occurrences = await getOccurences({ projectId, consequenceTypes, geneIds, impacts, currentFilters, caseIds });

  return {
    genes,
    occurences: occurrences.data.hits,
    cases: cases.data.hits,
  };
}

export default memoize(getQueries, {
  promise: true,
  normalizer: (args) => JSON.stringify(args[0]),
  max: 10,
});
