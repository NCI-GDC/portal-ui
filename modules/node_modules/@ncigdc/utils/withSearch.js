// @flow
import _ from 'lodash';
import withRouter from '@ncigdc/utils/withRouter';
import { SEARCH_FIELDS } from '@ncigdc/utils/constants';
import { fetchApi } from '@ncigdc/utils/ajax';
import { compose, withState, withHandlers, withProps, mapProps } from 'recompose';

const getPreviousItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) - 1) : _.last(items));
const getNextItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) + 1) : _.first(items));

export const withSearch = (propName = 'search', initialState) => {
  // eslint-disable-next-line fp/no-let
  let timeOfMostRecentRequest;
  const prefix = 'search.';
  const state = _.defaults(initialState, {
    results: [],
    highlightedResult: null,
    query: '',
    isLoading: false,
    isInSearchMode: false,
  });

  return compose(
    withState(`${prefix}state`, `${prefix}setState`, state),
    withRouter,
    withHandlers({
      [`${prefix}handleQueryChange`]: ({ [`${prefix}setState`]: setState }) => _.debounce(async (q) => {
        const query = q.trim();
        if (!query) {
          setState(s => ({ ...s, isInSearchMode: false, query: '' }));
          return;
        }
        setState(s => ({ ...s, query: s.query ? s.query : query, isLoading: true }));
        const timeOfCurrentRequest = new Date().getTime();
        // eslint-disable-next-line fp/no-mutation
        timeOfMostRecentRequest = timeOfCurrentRequest;
        // eslint-disable-next-line max-len
        const { data } = await fetchApi(`/all?fields=${SEARCH_FIELDS.join(',')}&query=${window.encodeURIComponent(query)}&size=5`);
        // prevent results that come back out-of-order from being displayed
        if (timeOfMostRecentRequest === timeOfCurrentRequest) {
          setState(s => ({ ...s, results: data.query.hits, query, isLoading: false }));
        }
      }, 350),
      [`${prefix}reset`]: ({ [`${prefix}setState`]: setState }) => () => {
        setState(s => ({ ...s, isInSearchMode: false, query: '' }));
      },
    }),
    withProps(({
      push,
      [`${prefix}state`]: state,
      [`${prefix}setState`]: setState,
      [`${prefix}reset`]: reset,
    }) => {
      const highlightItem = (highlightedResult: TSearchHit) => setState(s => ({ ...s, highlightedResult }));
      const selectItem = (result: TSearchHit) => {
        reset();
        push(`/${atob(result.id).split(':')[0].toLocaleLowerCase()}s/${atob(result.id).split(':')[1]}`);
      };
      return {
        [`${prefix}highlightItem`]: highlightItem,
        [`${prefix}selectItem`]: selectItem,
        [`${prefix}highlightPreviousItem`]: () => {
          if (_.isEmpty(state.results)) return;
          highlightItem(getPreviousItem(state.results, state.highlightedResult));
        },
        [`${prefix}highlightNextItem`]: () => {
          if (_.isEmpty(state.results)) return;
          highlightItem(getNextItem(state.results, state.highlightedResult));
        },
      };
    }),
    withHandlers({
      [`${prefix}handleKeyDown`]: ({
        [`${prefix}state`]: state,
        [`${prefix}selectItem`]: selectItem,
        [`${prefix}reset`]: reset,
        [`${prefix}highlightNextItem`]: highlightNextItem,
        [`${prefix}highlightPreviousItem`]: highlightPreviousItem,
      }) => (event) => ({
        ArrowUp: () => {
          event.preventDefault();
          highlightPreviousItem();
        },
        ArrowDown: () => {
          event.preventDefault();
          highlightNextItem();
        },
        Enter: () => state.highlightedResult && selectItem(state.highlightedResult),
        Escape: () => reset(),
      }[event.key] || _.noop)(),
    }),
    // namespace all props provided by this HoC under a propName (e.g. search.setState)
    mapProps(props => ({
      ...(_.omit(props, (value, key) => key.startsWith(prefix))),
      [propName]: _.mapKeys(
        _.pickBy(props, (value, key) => key.startsWith(prefix)),
        (value, key) => key.replace(new RegExp(`^${prefix}`), '')
      ),
    }))
  );
};

export default withSearch;
