/* @flow */
import { dataTypeTracks } from './tracks';

const dataTypesInitial = dataTypeTracks.reduce((acc, d) => ({ ...acc, [d.fieldName]: 0 }), {});

export type TDonorInput = {
  summary: {
    data_categories: Array<{data_category: string, file_count: number}>,
  },
  demographic: {
    gender: string,
    race: string,
    ethnicity: string,
  },
  case_id: string,
  diagnoses: Array<{
    age_at_diagnosis: number,
    vital_status: string,
    days_to_death: number,
    primary_diagnosis: string,
  }>,
};

export type TDonor = {
  id: string,
  gender: string,
  race: string,
  ethnicity: string,
  age: number,
  vitalStatus: boolean,
  daysToDeath: number,
};

function nullSentinel(value: ?number): number {
  if (value || value === 0) return value;
  return -777;
}

export const mapDonors = (donors: Array<TDonorInput>): Array<TDonor> => (
  donors.map(({ summary, demographic = {}, case_id, diagnoses = [] }): TDonor => {
    const { gender, race = 'not reported', ethnicity = 'not reported' } = demographic;
    const {
      age_at_diagnosis,
      vital_status: vitalStatus,
      days_to_death,
    } = diagnoses[0] || {};

    const output = { ...dataTypesInitial };

    summary.data_categories.forEach((category) => {
      output[category.data_category] = category.file_count || 0;
    });

    return {
      ...output,
      id: case_id,
      gender,
      race,
      ethnicity,
      age: nullSentinel(age_at_diagnosis),
      vitalStatus: vitalStatus === 'alive',
      daysToDeath: nullSentinel(days_to_death),
    };
  })
);

export type TGeneInput = {
  gene_id: string,
  symbol: string,
  _score: number,
  is_cancer_gene_census: boolean,
};

export type TGene = {
  id: string,
  symbol: string,
  totalDonors: number,
  cgc: boolean,
};

export const mapGenes = (genes: Array<TGeneInput>): Array<TGene> => (
  genes.map(({ gene_id, symbol, _score, is_cancer_gene_census: cgc }): TGene => ({
    id: gene_id,
    symbol,
    totalDonors: _score,
    cgc: !!cgc,
  }))
);

export type TOccurenceInput = {
  ssm: {
    ssm_id: string,
    consequence: Array<{
      transcript: {
        consequence_type: string,
        gene: {
          gene_id: string,
        },
        annotation: {
          impact: string,
        },
      }}>,
  },
  case: {
    case_id: string,
  },
};

export type TOccurence = {
  id: string,
  donorId: string,
  geneId: string,
  consequence: string,
  geneSymbol: string,
  functionalImpact: string,
};

function expandObs(geneIdToSymbol) {
  return ({ ssm, case: casObj = {} }): Array<TOccurence> => ssm.consequence
    .map(c => c.transcript)
    .map((consequence): TOccurence => {
      const { annotation = {}, gene = {}, consequence_type } = consequence;
      const geneId = gene.gene_id;

      return {
        // required
        id: ssm.ssm_id,
        donorId: casObj.case_id,
        geneId,
        consequence: consequence_type,

        // optional
        geneSymbol: geneIdToSymbol[geneId],
        functionalImpact: annotation.impact,
      };
    });
}

export const mapOccurences = (
  occurrences: Array<TOccurenceInput>,
  donors: Array<TDonor>,
  genes: Array<TGene>,
  consequenceTypes: Array<string>,
  impacts: Array<string>
): Array<TOccurence> => {
  const donorIds: Array<string> = donors.map((d: TDonor): string => d.id);
  const geneIds: Array<string> = genes.map((g: TGene): string => g.id);
  const geneIdToSymbol = genes.reduce((acc, g: TGene) => ({ ...acc, [g.id]: g.symbol }), {});

  function validOnco(occurrence: TOccurence): boolean {
    return (
      ((consequenceTypes || []).includes(occurrence.consequence)) &&
      geneIds.indexOf(occurrence.geneId) >= 0 &&
      donorIds.indexOf(occurrence.donorId) >= 0 &&
      (!impacts.length || impacts.includes(occurrence.functionalImpact))
    );
  }

  return occurrences.map(expandObs(geneIdToSymbol))
    .reduce((acc, occurrence) => [...acc, ...occurrence], [])
    .filter(validOnco);
};

export default { mapDonors, mapGenes, mapOccurences };
