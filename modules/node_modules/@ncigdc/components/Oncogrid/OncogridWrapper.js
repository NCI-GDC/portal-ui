/* @flow */
import React from 'react';
import { lifecycle, compose, withState, withProps } from 'recompose';
import OncoGrid from 'oncogrid';
import { uniqueId } from 'lodash';
import { insertRule } from 'glamor';
import { connect } from 'react-redux';

import { exitFullScreen, enterFullScreen, isFullScreen } from '@ncigdc/utils/fullscreen';
import { getFilterValue } from '@ncigdc/utils/filters';

import Button from '@ncigdc/uikit/Button';
import { Row, Column } from '@ncigdc/uikit/Flex';
import { Tooltip } from '@ncigdc/uikit/Tooltip';
import SpinnerParticle from '@ncigdc/uikit/Loaders/Particle';

import { StepLegend, SwatchLegend } from '@ncigdc/components/Legends';
import SelectModal from '@ncigdc/components/Modals/SelectModal';
import DownloadVisualizationButton from '@ncigdc/components/DownloadVisualizationButton';

import { visualizingButton } from '@ncigdc/theme/mixins';
import { setModal } from '@ncigdc/dux/modal';

import getQueries from './getQueries';
import oncoGridParams from './oncoGridParams';

function refreshGridState({
  oncoGrid,
  setHeatMapMode,
  setShowGridLines,
  setCrosshairMode,
}: {
  oncoGrid: Object,
  setHeatMapMode: Function,
  setShowGridLines: Function,
  setCrosshairMode: Function,
}): void {
  setHeatMapMode(oncoGrid.heatMapMode);
  setShowGridLines(oncoGrid.drawGridLines);
  setCrosshairMode(oncoGrid.crosshairMode);
}

const GRID_CLASS = 'oncogrid-wrapper';

const consequenceTypes = {
  missense_variant: '#ff9b6c',
  frameshift_variant: '#57dba4',
  start_lost: '#ff2323',
  stop_lost: '#d3ec00',
  initiator_codon_variant: '#5abaff',
  stop_gained: '#af57db',
};

const styles = {
  container: {
    overflow: 'visible',
    padding: '0 10px',
  },
  fullscreen: {
    maxWidth: '100%',
    width: '100%',
    marginLeft: 0,
    padding: '100px 100px 0',
    overflow: 'scroll',
    height: '100%',
  },
  button: {
    ...visualizingButton,
    marginBottom: 12,
  },
  buttonActive: {
    backgroundColor: '#e6e6e6',
    borderColor: '#adadad',
  },
  hidden: {
    width: 0,
    height: 0,
    overflow: 'hidden',
  },
};

const containerRefs = {};
const wrapperRefs = {};

type TProps = {
  oncoGrid: Object,
  setOncoGrid: Function,
  setOncoGridData: Function,
  oncoGridPadding: number,
  oncoGridHeight: number,
  setIsLoading: Function,
  projectId: string,
  setHeatMapMode: Function,
  setShowGridLines: Function,
  setCrosshairMode: Function,
  currentFilters: Object,
  uniqueGridClass: string,
  dispatch: Function,
};

const OncoGridWrapper = compose(
  withState('oncoGrid', 'setOncoGrid', {}),
  withState('oncoGridData', 'setOncoGridData', null),
  withState('crosshairMode', 'setCrosshairMode', false),
  withState('showGridLines', 'setShowGridLines', true),
  withState('heatMapMode', 'setHeatMapMode', false),
  withState('isLoading', 'setIsLoading', true),
  withState('uniqueGridClass', 'setUniqueGridClass', () => GRID_CLASS + uniqueId()),
  withProps({
    oncoGridHeight: 150,
    oncoGridPadding: 306,
    oncoGridWrapper: null,
    async getQueries(
      {
        oncoGrid,
        setOncoGrid,
        setOncoGridData,
        oncoGridPadding,
        oncoGridHeight,
        setIsLoading,
        projectId,
        setHeatMapMode,
        setShowGridLines,
        setCrosshairMode,
        currentFilters,
        uniqueGridClass,
        dispatch,
      }: TProps = {},
      previousResponses: Object
    ): Promise<*> {
      const responses = await getQueries({ projectId, consequenceTypes: Object.keys(consequenceTypes), currentFilters });

      const currentImpacts = getFilterValue({
        currentFilters: currentFilters.content,
        dotField: 'ssms.consequence.transcript.annotation.impact',
      });

      const gridParams = oncoGridParams({
        colorMap: consequenceTypes,
        element: wrapperRefs[uniqueGridClass],
        donorData: responses.cases,
        geneData: responses.genes,
        occurencesData: responses.occurences,
        width: (containerRefs[uniqueGridClass] || { offsetWidth: 0 }).offsetWidth - oncoGridPadding,
        height: oncoGridHeight,
        addTrackFunc: (options, callback) => {
          dispatch(setModal(
            <SelectModal
              options={options}
              onClose={
                (tracks = []) => {
                  dispatch(setModal(null));
                  if (tracks.length) callback(tracks);
                }
              }
            />
          ));
        },
        consequenceTypes: Object.keys(consequenceTypes),
        impacts: currentImpacts ? currentImpacts.content.value : ['HIGH'],
      });

      if (gridParams && !previousResponses) {
        const grid = new OncoGrid(gridParams);
        grid.render();
        setOncoGrid(grid);
        setOncoGridData(responses);
        refreshGridState({ oncoGrid: grid, setHeatMapMode, setShowGridLines, setCrosshairMode });
      } else if (gridParams && previousResponses) {
        if (oncoGrid.toggleGridLines) oncoGrid.destroy();
        const grid = new OncoGrid(gridParams);
        grid.render();
        setOncoGrid(grid);
        setOncoGridData(responses);
        refreshGridState({ oncoGrid: grid, setHeatMapMode, setShowGridLines, setCrosshairMode });
      } else if (!gridParams) {
        if (oncoGrid.toggleGridLines) oncoGrid.destroy();
        setOncoGridData(null);
      }

      setIsLoading(false);
    },
  }),
  connect(),
  lifecycle({
    componentWillReceiveProps(nextProps: Object): void {
      const {
        crosshairMode: lastCrosshairMode,
        showGridLines: lastShowGridLines,
        heatMapMode: lastHeadMapMode,
        width: lastWidth,
      } = this.props;

      const {
        oncoGrid,
        oncoGridPadding,
        oncoGridHeight,
        crosshairMode,
        showGridLines,
        heatMapMode,
        width,
        uniqueGridClass,
      } = nextProps;

      if (oncoGrid.toggleGridLines) {
        if (lastCrosshairMode !== crosshairMode) oncoGrid.toggleCrosshair();
        if (lastShowGridLines !== showGridLines) oncoGrid.toggleGridLines();
        if (lastHeadMapMode !== heatMapMode) oncoGrid.toggleHeatmap();
        if (width !== lastWidth) oncoGrid.resize(wrapperRefs[uniqueGridClass].offsetWidth - oncoGridPadding, oncoGridHeight);
      }

      if (JSON.stringify(this.props.currentFilters) !== JSON.stringify(nextProps.currentFilters)) {
        this.props.setIsLoading(true);
        this.props.getQueries(nextProps, this.props.oncoGridData);
      }
    },
    componentDidMount(): void {
      this.props.getQueries(this.props);
    },
    componentWillUnmount() {
      const { uniqueGridClass } = this.props;
      delete containerRefs[uniqueGridClass];
      delete wrapperRefs[uniqueGridClass];
    }
  })
)(({
  oncoGrid,
  oncoGridData,
  heatMapMode,
  setHeatMapMode,
  showGridLines,
  setShowGridLines,
  crosshairMode,
  setCrosshairMode,
  isLoading,
  uniqueGridClass,
}) => (
  <div
    style={{ ...styles.container, ...(isFullScreen() && styles.fullscreen) }}
    ref={r => { containerRefs[uniqueGridClass] = r; }}
  >
    <h5 style={{ textAlign: 'center' }}>Top 50 Mutated Genes by High Impact Mutations</h5>
    {oncoGridData && !isLoading &&
      <Row style={{ marginLeft: 0, minHeight: '70px' }}>
        <div style={{ flexGrow: 1 }}>
          {heatMapMode ? <StepLegend rightLabel="More Mutations" /> : <SwatchLegend colorMap={consequenceTypes} />}
        </div>
        <span>
          <DownloadVisualizationButton
            svg={`.${uniqueGridClass} svg`}
            data={oncoGridData}
            stylePrefix={`.${GRID_CLASS}`}
            slug="oncogrid"
            noText
            tooltipHTML="Download OncoGrid data or image"
          />
          <Tooltip Component="Reload grid">
            <Button
              style={styles.button}
              onClick={() => {
                oncoGrid.reload();
                refreshGridState({ oncoGrid, setHeatMapMode, setShowGridLines, setCrosshairMode });
              }}
            ><i className="fa fa-undo" /><span style={styles.hidden}>Reload</span></Button>
          </Tooltip>
          <Tooltip Component="Cluster Data">
            <Button
              style={styles.button}
              onClick={() => oncoGrid.cluster()}
            ><i className="fa fa-sort-amount-desc" /><span style={styles.hidden}>Cluster</span></Button>
          </Tooltip>
          <Tooltip Component="Toggle heatmap view">
            <Button
              style={{ ...styles.button, ...(heatMapMode && styles.buttonActive) }}
              onClick={() => setHeatMapMode(!heatMapMode)}
            ><i className="fa fa-fire" /><span style={styles.hidden}>Heatmap</span></Button>
          </Tooltip>
          <Tooltip Component="Toggle gridlines">
            <Button
              style={{ ...styles.button, ...(showGridLines && styles.buttonActive) }}
              onClick={() => setShowGridLines(!showGridLines)}
            ><i className="fa fa-th" /><span style={styles.hidden}>Lines</span></Button>
          </Tooltip>
          <Tooltip Component="Toggle crosshairs">
            <Button
              style={{ ...styles.button, ...(crosshairMode && styles.buttonActive) }}
              onClick={() => setCrosshairMode(!crosshairMode)}
            ><i className="fa fa-crosshairs" /><span style={styles.hidden}>Crosshair</span></Button>
          </Tooltip>
          <Tooltip Component="Fullscreen">
            <Button
              style={{
                ...styles.button,
                ...(isFullScreen() && styles.buttonActive),
                marginRight: 0,
              }}
              onClick={() => {
                if (isFullScreen()) {
                  exitFullScreen();
                  oncoGrid.reload();
                  refreshGridState({ oncoGrid, setHeatMapMode, setShowGridLines, setCrosshairMode });
                } else {
                  enterFullScreen(containerRefs[uniqueGridClass]);
                  oncoGrid.resize(screen.width - 400, screen.height - 400, true);
                }
              }}
            >
              <i className="fa fa-arrows-h" />
              <span style={styles.hidden}>Fullscreen</span>
            </Button>
          </Tooltip>

          {crosshairMode &&
            <div style={{ fontSize: '1.1rem', verticalAlign: 'top' }}>
              Click and drag to select a region on the OncoGrid to zoom in.
            </div>
          }
        </span>
      </Row>
    }
    {!oncoGridData && !isLoading &&
      <Column style={{ alignItems: 'center', padding: '2rem 0' }}>
        <div>No result found.</div>
        <div>Please note that the analysis is filtering on high impact mutations only.</div>
        <div>Please change your donor or gene set and run the analysis again.</div>
      </Column>
    }

    {isLoading &&
      <Column style={{ alignItems: 'center', padding: '2rem 0' }}>
        <SpinnerParticle />
        <div style={{ paddingTop: '2rem' }}>Loading OncoGrid...</div>
      </Column>
    }

    <div
      className={`${GRID_CLASS} ${uniqueGridClass}`}
      ref={n => { wrapperRefs[uniqueGridClass] = n; }}
      style={{
        cursor: crosshairMode ? 'crosshair' : 'pointer',
        visibility: isLoading ? 'hidden' : 'visible',
      }}
    />
  </div>
));

export default OncoGridWrapper;

/*----------------------------------------------------------------------------*/

insertRule(`
  .og-selection-region {
    fill: #1693c0;
  }
  .oncogrid-wrapper .background {
    fill: #fff;
    stroke: grey;
    stroke-width: 1;
    stroke-opacity: 0.5;
  }
  .oncogrid-wrapper line {
    stroke: grey;
    stroke-opacity: .3;
  }
  .oncogrid-wrapper .og-highlight {
    stroke: green;
    stroke-width: 1;
    z-index: 100;
  }
  .oncogrid-wrapper .og-histogram-axis {
    stroke: black;
    stroke-opacity: .5;
  }
  .oncogrid-wrapper .og-gene-label {
    cursor: move;
  }
  .oncogrid-wrapper text.og-label-text-font {
    font-size: 0.9rem;
  }
  .oncogrid-wrapper text.og-track-label {
    font-size: 0.9rem;
  }
  .oncogrid-wrapper .og-sortable-rect:hover {
    stroke: red;
    stroke-width: 2;
  }
  .oncogrid-wrapper .og-remove-gene {
    cursor: pointer;
    font-size: 0.98rem;
    font-family: sans-serif;
    fill: red;
    stroke: red;
  }
  .oncogrid-wrapper div.og-tooltip-oncogrid {
    font-weight: 300;
    position: absolute;
    z-index: 100001;
    display: block;
    visibility: visible;
    font-size: 1.28rem;
    pointer-events: none;
    line-height: 2.2rem;
    border: 1px solid #b3b3b3;
    background-color: #fff;
    border-radius: 3px;
    -webkit-filter: drop-shadow(0 1px 3px rgba(180, 180, 180, 0.43));
    box-shadow: 0 1px 3px rgba(180, 180, 180, 0.43);
    -moz-box-shadow: 0 1px 3px rgba(180, 180, 180, 0.43);
    filter: drop-shadow(0 1px 3px rgba(180, 180, 180, 0.43));
    padding: 5px;
  }
  .oncogrid-wrapper .og-horizontal-cross {
    stroke: black;
  }
  .oncogrid-wrapper .og-vertical-cross {
    stroke: black;
  }
`);
