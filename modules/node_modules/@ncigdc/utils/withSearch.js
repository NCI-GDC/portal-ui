// @flow
import _ from 'lodash';
import withRouter from '@ncigdc/utils/withRouter';
import { SEARCH_FIELDS } from '@ncigdc/utils/constants';
import { fetchApi } from '@ncigdc/utils/ajax';
import { compose, withState, withHandlers, withProps, mapProps, withPropsOnChange } from 'recompose';

const getPreviousItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) - 1) : _.last(items));
const getNextItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) + 1) : _.first(items));
const throttledInvoker = _.throttle((fn) => fn(), 300, { leading: false });

export const withSearch = (propName = 'search', passedInState) => {
  // prefix props to avoid collisions with existing props for component being enhanced
  const prefix = 'search.';
  const initialState = _.defaults(passedInState, {
    results: [],
    highlightedResult: null,
    query: '',
    isLoading: false,
    isInSearchMode: false,
  });

  // prevent results that come back out-of-order from being displayed
  // eslint-disable-next-line fp/no-let
  let timeOfMostRecentRequest = 0;

  return compose(
    withState(`${prefix}state`, `${prefix}setState`, initialState),
    withRouter,
    withProps(({
      [`${prefix}setState`]: setState,
    }) => ({
      [`${prefix}handleResults`]: (results, timeOfRequest) => {
        if (timeOfMostRecentRequest === timeOfRequest) {
          setState(s => ({ ...s, results, isLoading: false }));
        }
      },
    })),
    withHandlers(({
      [`${prefix}setQuery`]: ({ [`${prefix}setState`]: setState }) => (q) => {
        setState(s => ({ ...s, query: q.trim() }));
      },
      [`${prefix}reset`]: ({ [`${prefix}setState`]: setState }) => () => {
        setState(s => ({ ...s, query: '', isInSearchMode: false }));
      },
      [`${prefix}fetchResults`]: ({ [`${prefix}handleResults`]: handleResults }) =>
          (query, timeOfRequest) => throttledInvoker(
            () => fetchApi(`/all?fields=${SEARCH_FIELDS.join(',')}&query=${window.encodeURIComponent(query)}&size=5`)
              .then(response => handleResults(response.data.query.hits, timeOfRequest))
          ),
    })),
    withPropsOnChange(
      (props, nextProps) => props[`${prefix}state`].query !== nextProps[`${prefix}state`].query,
      ({
        [[`${prefix}state`]]: { query, results },
        [`${prefix}setState`]: setState,
        [`${prefix}fetchResults`]: fetchResults,
      }) => {
        // eslint-disable-next-line fp/no-mutation
        timeOfMostRecentRequest = new Date().getTime();
        if (query) {
          setState(s => ({ ...s, isLoading: true }));
          fetchResults(query, timeOfMostRecentRequest);
        } else if (results && results.length) {
          setState(s => ({ ...s, results: [] }));
        }
      }
    ),
    withProps(({
      push,
      [`${prefix}state`]: state,
      [`${prefix}setState`]: setState,
      [`${prefix}reset`]: reset,
    }) => {
      const highlightItem = (highlightedResult: TSearchHit) => setState(s => ({ ...s, highlightedResult }));
      const selectItem = (result: TSearchHit) => {
        push(`/${atob(result.id).split(':')[0].toLocaleLowerCase()}s/${atob(result.id).split(':')[1]}`);
        setTimeout(reset, 100);
      };
      return {
        [`${prefix}highlightItem`]: highlightItem,
        [`${prefix}selectItem`]: selectItem,
        [`${prefix}highlightPreviousItem`]: () => {
          if (_.isEmpty(state.results)) return;
          highlightItem(getPreviousItem(state.results, state.highlightedResult));
        },
        [`${prefix}highlightNextItem`]: () => {
          if (_.isEmpty(state.results)) return;
          highlightItem(getNextItem(state.results, state.highlightedResult));
        },
      };
    }),
    withHandlers({
      [`${prefix}handleKeyDown`]: ({
        [`${prefix}state`]: state,
        [`${prefix}selectItem`]: selectItem,
        [`${prefix}reset`]: reset,
        [`${prefix}highlightNextItem`]: highlightNextItem,
        [`${prefix}highlightPreviousItem`]: highlightPreviousItem,
      }) => (event) => ({
        ArrowUp: () => {
          event.preventDefault();
          highlightPreviousItem();
        },
        ArrowDown: () => {
          event.preventDefault();
          highlightNextItem();
        },
        Enter: () => state.highlightedResult && selectItem(state.highlightedResult),
        Escape: () => reset(),
      }[event.key] || _.noop)(),
    }),
    // namespace all props provided by this HoC under a propName (e.g. search.setState)
    mapProps(props => ({
      ...(_.omit(props, (value, key) => key.startsWith(prefix))),
      [propName]: _.mapKeys(
        _.pickBy(props, (value, key) => key.startsWith(prefix)),
        (value, key) => key.replace(new RegExp(`^${prefix}`), '')
      ),
    }))
  );
};

export default withSearch;
