/* @flow */
import React from 'react';
import { lifecycle, compose, withState, withProps } from 'recompose';
import OncoGrid from 'oncogrid';
import { uniqueId } from 'lodash';
import { connect } from 'react-redux';
import withSize from '@ncigdc/utils/withSize';

import { exitFullScreen, enterFullScreen, isFullScreen } from '@ncigdc/utils/fullscreen';
import { getFilterValue } from '@ncigdc/utils/filters';
import withRouter from '@ncigdc/utils/withRouter';

import Loader from '@ncigdc/uikit/Loaders/Loader';
import Button from '@ncigdc/uikit/Button';
import { Row, Column } from '@ncigdc/uikit/Flex';
import { Tooltip } from '@ncigdc/uikit/Tooltip';

import { StepLegend, SwatchLegend } from '@ncigdc/components/Legends';
import SelectModal from '@ncigdc/components/Modals/SelectModal';
import DownloadVisualizationButton from '@ncigdc/components/DownloadVisualizationButton';
import Hidden from '@ncigdc/components/Hidden';

import { visualizingButton } from '@ncigdc/theme/mixins';
import { setModal } from '@ncigdc/dux/modal';
import wrapSvg from '@ncigdc/utils/wrapSvg';

import getQueries from './getQueries';
import oncoGridParams from './oncoGridParams';

import './oncogrid.css';

const TITLE = 'Top 50 Genes by High Impact (VEP) Mutations';

function refreshGridState({
  oncoGrid,
  setHeatMapMode,
  setShowGridLines,
  setCrosshairMode,
}: {
  oncoGrid: Object,
  setHeatMapMode: Function,
  setShowGridLines: Function,
  setCrosshairMode: Function,
}): void {
  setHeatMapMode(oncoGrid.heatMapMode);
  setShowGridLines(oncoGrid.drawGridLines);
  setCrosshairMode(oncoGrid.crosshairMode);
}

const GRID_CLASS = 'oncogrid-wrapper';

const consequenceTypes = {
  missense_variant: '#ff9b6c',
  frameshift_variant: '#57dba4',
  start_lost: '#ff2323',
  stop_lost: '#d3ec00',
  initiator_codon_variant: '#5abaff',
  stop_gained: '#af57db',
};

const styles = {
  container: {
    overflow: 'visible',
    padding: '0 10px',
  },
  fullscreen: {
    maxWidth: '100%',
    width: '100%',
    marginLeft: 0,
    padding: '100px 100px 0',
    overflow: 'scroll',
    height: '100%',
  },
  button: {
    ...visualizingButton,
    marginBottom: 12,
  },
  buttonActive: {
    backgroundColor: '#e6e6e6',
    borderColor: '#adadad',
  },
};

const containerRefs = {};
const wrapperRefs = {};

type TProps = {
  oncoGrid: Object,
  setOncoGrid: Function,
  setOncoGridData: Function,
  oncoGridPadding: number,
  oncoGridHeight: number,
  setIsLoading: Function,
  projectId: string,
  setHeatMapMode: Function,
  setShowGridLines: Function,
  setCrosshairMode: Function,
  setTrackLegends: Function,
  currentFilters: Object,
  uniqueGridClass: string,
  dispatch: Function,
  push: Function,
};

const OncoGridWrapper = compose(
  withRouter,
  withState('oncoGrid', 'setOncoGrid', {}),
  withState('oncoGridData', 'setOncoGridData', null),
  withState('crosshairMode', 'setCrosshairMode', false),
  withState('showGridLines', 'setShowGridLines', true),
  withState('heatMapMode', 'setHeatMapMode', false),
  withState('isLoading', 'setIsLoading', true),
  withState('uniqueGridClass', 'setUniqueGridClass', () => GRID_CLASS + uniqueId()),
  withState('trackLegends', 'setTrackLegends', []),
  withProps({
    oncoGridHeight: 150,
    oncoGridPadding: 306,
    oncoGridWrapper: null,
    async getQueries(
      {
        oncoGrid,
        setOncoGrid,
        setOncoGridData,
        oncoGridPadding,
        oncoGridHeight,
        setIsLoading,
        projectId,
        setHeatMapMode,
        setShowGridLines,
        setCrosshairMode,
        setTrackLegends,
        currentFilters,
        uniqueGridClass,
        dispatch,
        push,
      }: TProps = {},
      previousResponses: Object
    ): Promise<*> {
      const responses = await getQueries({
        projectId,
        consequenceTypes: Object.keys(consequenceTypes),
        currentFilters,
      });
      if (!wrapperRefs[uniqueGridClass]) return;

      const currentImpacts = getFilterValue({
        currentFilters: currentFilters.content,
        dotField: 'ssms.consequence.transcript.annotation.impact',
      });

      const gridParams = oncoGridParams({
        colorMap: consequenceTypes,
        element: wrapperRefs[uniqueGridClass],
        donorData: responses.cases,
        geneData: responses.genes,
        occurencesData: responses.occurences,
        width: (containerRefs[uniqueGridClass] || { offsetWidth: 0 }).offsetWidth - oncoGridPadding,
        height: oncoGridHeight,
        geneClick: ({ id }: { id: string}) => push(`/genes/${id}`),
        donorClick: ({ id }: { id: string }) => push(`/cases/${id}`),
        addTrackFunc: (options, callback) => {
          dispatch(setModal(
            <SelectModal
              options={options}
              onClose={
                (tracks = []) => {
                  dispatch(setModal(null));
                  if (tracks.length) callback(tracks);
                }
              }
            />
          ));
        },
        consequenceTypes: Object.keys(consequenceTypes),
        impacts: currentImpacts ? currentImpacts.content.value : ['HIGH'],
      });

      if (gridParams && !previousResponses) {
        const grid = new OncoGrid(gridParams);
        grid.render();
        setOncoGrid(grid);
        setOncoGridData(responses);
        refreshGridState({ oncoGrid: grid, setHeatMapMode, setShowGridLines, setCrosshairMode });
      } else if (gridParams && previousResponses) {
        if (oncoGrid.toggleGridLines) oncoGrid.destroy();
        const grid = new OncoGrid(gridParams);
        grid.render();
        setOncoGrid(grid);
        setOncoGridData(responses);
        refreshGridState({ oncoGrid: grid, setHeatMapMode, setShowGridLines, setCrosshairMode });
      } else if (!gridParams) {
        if (oncoGrid.toggleGridLines) oncoGrid.destroy();
        setOncoGridData(null);
      }

      if (gridParams) {
        setTrackLegends(Object.values(gridParams.trackLegends));
      }

      setIsLoading(false);
    },
  }),
  connect(),
  withSize(),
  lifecycle({
    componentWillReceiveProps(nextProps: Object): void {
      const {
        crosshairMode: lastCrosshairMode,
        showGridLines: lastShowGridLines,
        heatMapMode: lastHeadMapMode,
        size: {
          width: lastWidth,
        },
      } = this.props;

      const {
        oncoGrid,
        oncoGridPadding,
        oncoGridHeight,
        crosshairMode,
        showGridLines,
        heatMapMode,
        size: {
          width,
        },
        uniqueGridClass,
      } = nextProps;

      if (oncoGrid.toggleGridLines) {
        if (lastCrosshairMode !== crosshairMode) oncoGrid.toggleCrosshair();
        if (lastShowGridLines !== showGridLines) oncoGrid.toggleGridLines();
        if (lastHeadMapMode !== heatMapMode) oncoGrid.toggleHeatmap();
        if (width !== lastWidth) {
          oncoGrid.resize(wrapperRefs[uniqueGridClass].offsetWidth - oncoGridPadding, oncoGridHeight);
        }
      }

      if (JSON.stringify(this.props.currentFilters) !== JSON.stringify(nextProps.currentFilters)) {
        this.props.setIsLoading(true);
        this.props.getQueries(nextProps, this.props.oncoGridData);
      }
    },
    componentDidMount(): void {
      this.props.getQueries(this.props);
    },
    componentWillUnmount(): void {
      const { uniqueGridClass } = this.props;
      delete containerRefs[uniqueGridClass]; // eslint-disable-line fp/no-delete
      delete wrapperRefs[uniqueGridClass]; // eslint-disable-line fp/no-delete
    },
  })
)(({
  oncoGrid,
  oncoGridData,
  heatMapMode,
  setHeatMapMode,
  showGridLines,
  setShowGridLines,
  crosshairMode,
  setCrosshairMode,
  isLoading,
  uniqueGridClass,
  trackLegends,
}) => (
  <Loader
    loading={isLoading}
    height="800px"
  >
    <div
      style={{ ...styles.container, ...(isFullScreen() && styles.fullscreen) }}
      ref={r => { containerRefs[uniqueGridClass] = r; }} // eslint-disable-line fp/no-mutation
    >
      <h5 style={{ textAlign: 'center' }}>{TITLE}</h5>
      {oncoGridData && !isLoading &&
        <Row style={{ marginLeft: 0, minHeight: '70px' }}>
          <div style={{ flexGrow: 1 }} className="oncogrid-legend">
            {heatMapMode ? <StepLegend rightLabel="More Mutations" /> : <SwatchLegend colorMap={consequenceTypes} />}
          </div>
          <Row style={{ justifyContent: 'flex-end', marginRight: '12px', flexWrap: 'wrap' }} spacing="1rem">
            <DownloadVisualizationButton
              svg={() => {
                const elementsAfter = trackLegends.map((html) => {
                  const div = document.createElement('div');
                  div.innerHTML = html;
                  div.style.position = 'absolute';
                  div.style.left = '-99999px';
                  document.body.appendChild(div);
                  return div;
                });

                const wrappedSvg = wrapSvg({
                  selector: `.${uniqueGridClass} svg`,
                  title: TITLE,
                  className: GRID_CLASS,
                  embed: {
                    top: {
                      elements: [
                        containerRefs[uniqueGridClass].querySelector('.oncogrid-legend'),
                      ],
                    },
                    bottom: {
                      elements: elementsAfter,
                      styles: 'display: inline-block; width: 200px; vertical-align: top; ',
                    },
                  },
                });

                elementsAfter.forEach(el => document.body.removeChild(el));

                return wrappedSvg;
              }}
              data={oncoGridData}
              stylePrefix={`.${GRID_CLASS}`}
              slug="oncogrid"
              noText
              tooltipHTML="Download OncoGrid data or image"
            />
            <Tooltip Component="Reload grid">
              <Button
                style={styles.button}
                onClick={() => {
                  oncoGrid.reload();
                  refreshGridState({ oncoGrid, setHeatMapMode, setShowGridLines, setCrosshairMode });
                }}
              ><i className="fa fa-undo" /><Hidden>Reload</Hidden></Button>
            </Tooltip>
            <Tooltip Component="Cluster Data">
              <Button
                style={styles.button}
                onClick={() => oncoGrid.cluster()}
              ><i className="fa fa-sort-amount-desc" /><Hidden>Cluster</Hidden></Button>
            </Tooltip>
            <Tooltip Component="Toggle heatmap view">
              <Button
                style={{ ...styles.button, ...(heatMapMode && styles.buttonActive) }}
                onClick={() => setHeatMapMode(!heatMapMode)}
              ><i className="fa fa-fire" /><Hidden>Heatmap</Hidden></Button>
            </Tooltip>
            <Tooltip Component="Toggle gridlines">
              <Button
                style={{ ...styles.button, ...(showGridLines && styles.buttonActive) }}
                onClick={() => setShowGridLines(!showGridLines)}
              ><i className="fa fa-th" /><Hidden>Lines</Hidden></Button>
            </Tooltip>
            <Tooltip Component="Toggle crosshairs">
              <Button
                style={{ ...styles.button, ...(crosshairMode && styles.buttonActive) }}
                onClick={() => setCrosshairMode(!crosshairMode)}
              ><i className="fa fa-crosshairs" /><Hidden>Crosshair</Hidden></Button>
            </Tooltip>
            <Tooltip Component="Fullscreen">
              <Button
                style={{
                  ...styles.button,
                  ...(isFullScreen() && styles.buttonActive),
                  marginRight: 0,
                }}
                onClick={() => {
                  if (isFullScreen()) {
                    exitFullScreen();
                    oncoGrid.reload();
                    refreshGridState({ oncoGrid, setHeatMapMode, setShowGridLines, setCrosshairMode });
                  } else {
                    enterFullScreen(containerRefs[uniqueGridClass]);
                    oncoGrid.resize(screen.width - 400, screen.height - 400, true);
                  }
                }}
              >
                <i className="fa fa-arrows-h" />
                <Hidden>Fullscreen</Hidden>
              </Button>
            </Tooltip>

            {crosshairMode &&
              <div style={{ fontSize: '1.1rem', verticalAlign: 'top', width: '100%', textAlign: 'right' }}>
                Click and drag to select a region on the OncoGrid to zoom in.
              </div>
            }
          </Row>
        </Row>
      }
      {!oncoGridData && !isLoading &&
        <Column style={{ alignItems: 'center', padding: '2rem 0' }}>
          <div>No result found.</div>
          <div>Please note that the analysis is filtering on high impact mutations only.</div>
          <div>Please change your donor or gene set and run the analysis again.</div>
        </Column>
      }

      <div
        className={`${GRID_CLASS} ${uniqueGridClass}`}
        ref={n => { wrapperRefs[uniqueGridClass] = n; }} // eslint-disable-line fp/no-mutation
        style={{
          cursor: crosshairMode ? 'crosshair' : 'pointer',
          visibility: isLoading ? 'hidden' : 'visible',
        }}
      />
    </div>
  </Loader>
));

export default OncoGridWrapper;
