// @flow

// Vendor
import React from 'react';
import { REHYDRATE } from 'redux-persist/constants';
import _ from 'lodash';
import UndoIcon from 'react-icons/lib/md/undo';

import { stringify } from 'query-string';
import { fetchApi } from '@ncigdc/utils/ajax';
import { notify } from '@ncigdc/dux/notification';
import { Column } from '@ncigdc/uikit/Flex';
import { center } from '@ncigdc/theme/mixins';
import styled from '@ncigdc/theme/styled';

/*----------------------------------------------------------------------------*/

const UPDATE_CART = 'UPDATE_CART';
const ADD_CART = 'ADD_CART';
const REMOVE_CART = 'REMOVE_CART';

const NotificationColumn = styled(Column, ({
  textAlign: 'center',
  wordBreak: 'break-word'
}));

const getNotificationComponent = (action, id, notification, dispatch) => ({
  action: action,
  id: id,
  component:
    <NotificationColumn>
      <span>{notification.action} <strong>{notification.file}</strong> {notification.prapositon} {notification.fileText}the cart. {notification.extraText} </span>
      {notification.undo &&
         <span style={center}>
          <UndoIcon />
          <a onClick={() => dispatch(toggleFilesInCart(notification.undo.files))}>Undo</a>
        </span>
      }
    </NotificationColumn>,
});

function toggleFilesInCart(incomingFile) {
  return (dispatch, getState) => {
    const incomingFileArray = incomingFile.constructor === Array ? incomingFile : [incomingFile];
    const existingFiles = getState().cart.files;
    const nextFiles = _.xorBy(existingFiles, incomingFileArray, 'file_id');

    if (nextFiles.length > existingFiles.length) {
      dispatch(notify(getNotificationComponent('add', `add/${incomingFile.file_name}`, {
        action: 'Added',
        file: incomingFile.file_name,
        prapositon: 'to',
        undo: {
          files: incomingFile
        }
      }, dispatch)));
    }

    if (nextFiles.length < existingFiles.length) {
      dispatch(notify(getNotificationComponent('remove', `remove/${incomingFile.file_name}`, {
        action: 'Removed',
        file: incomingFile.file_name || incomingFileArray.length,
        prapositon: 'from',
        undo: {
          files: incomingFile
        }
      }, dispatch)));
    }

    dispatch({
      type: UPDATE_CART,
      payload: nextFiles,
    });
  };
}

function fetchFiles (currentFilters, total) {
  return async dispatch => {
    if (total <= 10000){
      const search = stringify({
        filters: JSON.stringify(currentFilters),
        size: total,
        fields: 'access,file_id,file_size,cases.project.project_id'
      });
      const { data } = await fetchApi(`files?${search}`);
      dispatch(addAllFilesInCart(data.hits))
    } else {
      dispatch(notify({
        action: 'add',
        component:
          <NotificationColumn>
            <span>The cart is limited to 10,000 files. Please narrow down your search criteria to be able to add files to your cart.</span>
          </NotificationColumn>,
      }));
    }
  }
}

function addAllFilesInCart(incomingFiles) {
  return (dispatch, getState) => {
    const incomingFilesArray = incomingFiles.constructor === Array ? incomingFiles : [incomingFiles];
    const existingFiles = getState().cart.files;
    const nextFiles = _.filter(incomingFilesArray, (file) => !_.some(existingFiles, {'file_id':file.file_id}));
    const filesInCart = incomingFilesArray.length - nextFiles.length;

    if(nextFiles && nextFiles.length < incomingFilesArray.length){
      dispatch(notify(getNotificationComponent('add', `add/some`, {
        action: 'Added',
        file: nextFiles.length,
        fileText: nextFiles.length>1 ? 'files ' : 'file ',
        extraText: `<strong>${filesInCart}</strong> ${filesInCart>1 ? 'files' : 'file'} already in cart, not added.`,
        prapositon: 'to',
        undo: {
          files: incomingFiles
        }
      }, dispatch)));
    } else if(nextFiles){
      dispatch(notify(getNotificationComponent('add', `add/all`, {
        action: 'Added',
        file: nextFiles.length,
        fileText: 'files ',
        prapositon: 'to',
        undo: {
          files: incomingFiles
        }
      }, dispatch)));
    }
    dispatch({
      type: ADD_CART,
      payload: nextFiles,
    });
  }
}

function removeAllInCart(){
  return (dispatch, getState) => {
    const existingFiles = getState().cart.files;
    if(existingFiles.length){
      dispatch(notify(getNotificationComponent('remove', `remove/all`, {
        action: 'Removed',
        file: existingFiles.length,
        fileText: 'files ',
        prapositon: 'from',
        undo: {
          files: existingFiles
        }
      }, dispatch)));

      dispatch({
        type: REMOVE_CART,
        payload: [],
      });
    } else {
      dispatch(notify({
        action: 'remove',
        id: 'remove/nofile',
        component:
          <NotificationColumn>
            <span>There are no files in the cart</span>
          </NotificationColumn>,
      }));
    }
  }
}

const initialState = {
  files: [],
};

function reducer(state = initialState, action) {
  switch (action.type) {
    case REHYDRATE: {
      const incoming = action.payload.cart;
      if (incoming) return { ...state, ...incoming };
      return state;
    }
    case ADD_CART:
      return {
        files: state.files.concat(action.payload.map(file => ({
          access: file.access,
          file_id: file.file_id,
          file_size: file.file_size,
          projects: file.projects || file.cases.map(c => c.project.project_id),
        }))),
      };
    case REMOVE_CART:
      return {
        files: [],
      };
    case UPDATE_CART:
      return {
        ...state,
        files: action.payload.map(f => ({
          access: f.access,
          file_id: f.file_id,
          file_size: f.file_size,
          projects: f.projects || f.cases.map(c => c.project.project_id),
        })),
      };

    default:
      return state;
  }
}

/*----------------------------------------------------------------------------*/

export { toggleFilesInCart, addAllFilesInCart, removeAllInCart, fetchFiles };
export default reducer;
