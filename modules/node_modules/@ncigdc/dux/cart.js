// @flow

// Vendor
import React from 'react';
import { REHYDRATE } from 'redux-persist/constants';
import _ from 'lodash';

import { stringify } from 'query-string';
import { fetchApi } from '@ncigdc/utils/ajax';
import { notify } from '@ncigdc/dux/notification';
import { Column } from '@ncigdc/uikit/Flex';
import { center } from '@ncigdc/theme/mixins';

/*----------------------------------------------------------------------------*/

export const UPDATE_CART = 'UPDATE_CART';
export const ADD_TO_CART = 'ADD_TO_CART';
export const CLEAR_CART = 'CLEAR_CART';
export const CART_FULL = 'CART_FULL';

export const MAX_CART_SIZE = 10000;
const getNotificationComponent = (action, id, notification, dispatch) => ({
  action,
  id,
  component:
  <Column>
    <span>
      {notification.action}
      <strong> {notification.file} </strong>
      {notification.fileText}{notification.prepositon} the cart. {notification.extraText}
    </span>
    {notification.undo &&
    <span style={center}>
      <strong>
        <i
          className="fa fa-undo"
          style={{
            marginRight: '0.3rem',
          }}
        />
        <a
          style={{
            textDecoration: 'underline',
          }}
          onClick={() => dispatch(toggleFilesInCart(notification.undo.files))}
        >
          Undo
        </a>
      </strong>
    </span>
    }
  </Column>,
});

const fullNotificationDispatcher = (dispatch: Function) => {
  dispatch(notify({
    action: 'warning',
    id: `${(new Date()).getTime()}`,
    component: (
      <Column>
        <span>
          The cart is limited to {MAX_CART_SIZE.toLocaleString()} files.
          Please narrow the search criteria or remove some files from the cart to add more.
        </span>
      </Column>
      ),
  }));
};

function toggleFilesInCart(incomingFile) {
  return (dispatch, getState) => {
    const incomingFileArray = incomingFile.constructor === Array ? incomingFile : [incomingFile];
    const existingFiles = getState().cart.files;
    const nextFiles = _.xorBy(existingFiles, incomingFileArray, 'file_id');

    if (nextFiles.length > MAX_CART_SIZE) {
      dispatch({
        type: CART_FULL,
      });
      fullNotificationDispatcher(dispatch);
      return;
    }

    if (nextFiles.length > existingFiles.length) {
      dispatch(notify(getNotificationComponent('add', `add/${incomingFile.file_name}`, {
        action: 'Added',
        file: incomingFile.file_name,
        prepositon: 'to',
        undo: {
          files: incomingFile,
        },
      }, dispatch)));
    }

    if (nextFiles.length < existingFiles.length) {
      dispatch(notify(getNotificationComponent('remove', `remove/${incomingFile.file_name}`, {
        action: 'Removed',
        file: incomingFile.file_name || incomingFileArray.length,
        fileText: incomingFile.file_name ? '' : 'files ',
        prepositon: 'from',
        undo: {
          files: incomingFile,
        },
      }, dispatch)));
    }

    dispatch({
      type: UPDATE_CART,
      payload: nextFiles,
    });
  };
}

function removeFilesFromCart(files) {
  return (dispatch, getState) => {
    const filesToRemove = _.isArray(files) ? files : [files];
    const existingFiles = getState().cart.files;
    const nextFiles = _.differenceBy(existingFiles, filesToRemove, 'file_id');
    const filesRemoved = existingFiles.length - nextFiles.length;
    dispatch(notify(getNotificationComponent('remove', `remove/${(new Date()).getTime()}`, {
      action: 'Removed',
      file: filesToRemove.file_name || filesRemoved,
      fileText: filesToRemove.file_name ? '' : 'files ',
      prepositon: 'from',
      undo: {
        files: filesToRemove,
      },
    }, dispatch)));

    dispatch({
      type: UPDATE_CART,
      payload: nextFiles,
    });
  };
}

function addAllFilesInCart(incomingFiles) {
  return (dispatch, getState) => {
    const incomingFilesArray = incomingFiles.constructor === Array ? incomingFiles : [incomingFiles];
    const existingFiles = getState().cart.files;
    const nextFiles = incomingFilesArray.filter(
      (file) => !existingFiles.some(
        (existingFile) => existingFile.file_id === file.file_id));
    const filesInCart = incomingFilesArray.length - nextFiles.length;

    if (nextFiles.length + existingFiles.length > MAX_CART_SIZE) {
      dispatch({
        type: CART_FULL,
      });
      fullNotificationDispatcher(dispatch);
      return;
    }
    if (nextFiles && nextFiles.length < incomingFilesArray.length) {
      dispatch(notify(getNotificationComponent('add', `add/some${(new Date()).getTime()}`, {
        action: 'Added',
        file: nextFiles.length,
        fileText: nextFiles.length > 1 ? 'files ' : 'file ',
        extraText: (
          <span>
            <strong>{filesInCart}</strong> {filesInCart > 1 ? 'files' : 'file'} already in cart, not added.
          </span>
        ),
        prepositon: 'to',
        undo: {
          files: incomingFiles,
        },
      }, dispatch)));
    } else if (nextFiles) {
      dispatch(notify(getNotificationComponent('add', `add/all${(new Date()).getTime()}`, {
        action: 'Added',
        file: nextFiles.length,
        fileText: 'files ',
        prepositon: 'to',
        undo: {
          files: incomingFiles,
        },
      }, dispatch)));
    }
    dispatch({
      type: ADD_TO_CART,
      payload: nextFiles,
    });
  };
}

function fetchFiles(currentFilters, total) {
  return async (dispatch) => {
    // if the total requested in filters is larger than max cart then don't bother fetching
    // otherwise need the IDs to tell if they are already in the cart
    if (total <= MAX_CART_SIZE) {
      const search = stringify({
        filters: JSON.stringify(currentFilters),
        size: total,
        fields: 'access,file_id,file_size,cases.project.project_id',
      });
      const { data } = await fetchApi(`files?${search}`);
      dispatch(addAllFilesInCart(data.hits));
    } else {
      dispatch({
        type: CART_FULL,
      });
      fullNotificationDispatcher(dispatch);
    }
  };
}

function removeAllInCart() {
  return (dispatch, getState) => {
    const existingFiles = getState().cart.files;
    if (existingFiles.length){
      dispatch(notify(getNotificationComponent('remove', `remove/all${(new Date()).getTime()}`, {
        action: 'Removed',
        file: existingFiles.length,
        fileText: 'files ',
        prepositon: 'from',
        undo: {
          files: existingFiles,
        }
      }, dispatch)));

      dispatch({
        type: CLEAR_CART,
        payload: [],
      });
    } else {
      dispatch(notify({
        action: 'remove',
        id: 'remove/nofile',
        component:
  <Column>
    <span>There are no files in the cart</span>
  </Column>,
      }));
    }
  };
}

const initialState = {
  files: [],
};

export function reducer(state = initialState, action) {
  switch (action.type) {
    case REHYDRATE: {
      const incoming = action.payload.cart;
      if (incoming) return { ...state, ...incoming };
      return state;
    }
    case ADD_TO_CART:
      return {
        files: state.files.concat(action.payload.map(file => ({
          access: file.access,
          file_id: file.file_id,
          file_size: file.file_size,
          projects: file.projects
          || (Array.isArray(file.cases)
            ? file.cases.map(c => c.project.project_id)
            : file.cases.hits.edges.map(c => c.node.project.project_id)),
        }))),
      };
    case CLEAR_CART:
      return {
        files: [],
      };
    case UPDATE_CART:
      return {
        ...state,
        files: action.payload.map(file => ({
          access: file.access,
          file_id: file.file_id,
          file_size: file.file_size,
          projects: file.projects
          || (Array.isArray(file.cases)
            ? file.cases.map(c => c.project.project_id)
            : file.cases.hits.edges.map(c => c.node.project.project_id)),
        })),
      };
    case CART_FULL:
      return state;
    default:
      return state;
  }
}

/*----------------------------------------------------------------------------*/

export {
  toggleFilesInCart,
  addAllFilesInCart,
  removeAllInCart,
  removeFilesFromCart,
  fetchFiles,
};
export default reducer;
