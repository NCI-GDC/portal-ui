// @flow
import _ from 'lodash';
import withRouter from '@ncigdc/utils/withRouter';
import { SEARCH_FIELDS } from '@ncigdc/utils/constants';
import { fetchApi } from '@ncigdc/utils/ajax';
import { compose, withState, withHandlers, withProps, withPropsOnChange } from 'recompose';
import type { TSearchHit } from '@ncigdc/components/QuickSearch/types';

const getPreviousItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) - 1) : _.last(items));
const getNextItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) + 1) : _.first(items));
const throttledInvoker = _.throttle((fn) => fn(), 300, { leading: false });

export const withSearch = (passedInState) => {
  // prefix props to avoid collisions with existing props for component being enhanced
  const defaultState = {
    results: [],
    highlightedResult: null,
    query: '',
    isLoading: false,
    isInSearchMode: false,
  };

  // prevent results that come back out-of-order from being displayed
  // eslint-disable-next-line fp/no-let
  let timeOfMostRecentRequest = 0;

  return compose(
    withState('state', 'setState', _.defaults(passedInState, defaultState)),
    withRouter,
    withProps(({
      setState,
    }) => ({
      handleResults: (results, timeOfRequest) => {
        if (timeOfMostRecentRequest === timeOfRequest) {
          setState(s => ({ ...s, results, isLoading: false }));
        }
      },
    })),
    withHandlers(({
      setQuery: ({ setState }) => (q) => {
        setState(s => ({ ...s, query: q.trim() }));
      },
      reset: ({ setState }) => () => {
        setState(s => ({ ...s, query: '', isInSearchMode: false }));
      },
      fetchResults: ({ handleResults }) =>
          (query, timeOfRequest) => throttledInvoker(
            () => fetchApi(`/all?fields=${SEARCH_FIELDS.join(',')}&query=${window.encodeURIComponent(query)}&size=5`)
              .then(response => handleResults(response.data.query.hits, timeOfRequest))
          ),
    })),
    withPropsOnChange(
      (props, nextProps) => props.state.query !== nextProps.state.query,
      ({
        state: { query, results },
        setState,
        fetchResults,
      }) => {
        // eslint-disable-next-line fp/no-mutation
        timeOfMostRecentRequest = new Date().getTime();
        if (query) {
          setState(s => ({ ...s, isLoading: true }));
          fetchResults(query, timeOfMostRecentRequest);
        } else if (results && results.length) {
          setState(s => ({ ...s, results: [] }));
        }
      }
    ),
    withProps(({
      push,
      state,
      setState,
      reset,
    }) => {
      const highlightItem = (highlightedResult: TSearchHit) => setState(s => ({ ...s, highlightedResult }));
      const selectItem = (result: TSearchHit) => {
        push(`/${atob(result.id).split(':')[0].toLocaleLowerCase()}s/${atob(result.id).split(':')[1]}`);
        setTimeout(reset, 100);
      };
      return {
        highlightItem,
        selectItem,
        highlightPreviousItem: () => {
          if (_.isEmpty(state.results)) return;
          highlightItem(getPreviousItem(state.results, state.highlightedResult));
        },
        highlightNextItem: () => {
          if (_.isEmpty(state.results)) return;
          highlightItem(getNextItem(state.results, state.highlightedResult));
        },
      };
    }),
    withHandlers({
      handleKeyDown: ({
        state,
        selectItem,
        reset,
        highlightNextItem,
        highlightPreviousItem,
      }) => (event) => ({
        ArrowUp: () => {
          event.preventDefault();
          highlightPreviousItem();
        },
        ArrowDown: () => {
          event.preventDefault();
          highlightNextItem();
        },
        Enter: () => state.highlightedResult && selectItem(state.highlightedResult),
        Escape: () => reset(),
      }[event.key] || _.noop)(),
    })
  );
};

export default withSearch;
