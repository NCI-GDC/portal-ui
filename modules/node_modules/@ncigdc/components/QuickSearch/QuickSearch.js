// @flow

import React from 'react';
import _ from 'lodash';
import { compose, withState, withHandlers } from 'recompose';
import withRouter from '@ncigdc/utils/withRouter';
import styled from '@ncigdc/theme/styled';
import { SEARCH_FIELDS } from '@ncigdc/utils/constants';
import { fetchApi } from '@ncigdc/utils/ajax';
import QuickSearchResults from './QuickSearchResults';
import type { TSearchHit } from './types';

const styles = {
  searchIconWrapper: {
    marginRight: '4px',
    position: 'relative',
  },
  searchIcon: {
    // add a bit of transition delay to avoid jank with really fast queries
    transition: 'opacity 0.2s ease 0.1s',
  },
  loadingIcon: {
    position: 'absolute',
    left: 0,
    top: 0,
    transition: 'opacity 0.2s ease 0.1s',
  },
  invisible: {
    opacity: 0,
  },
  visible: {
    opacity: 1,
  },
  container: {
    position: 'relative',
  },
};

const SearchInput = styled.input({
  fontSize: '14px',
  height: '3rem',
  padding: '0.7rem 1rem',
  border: ({ theme }) => `1px solid ${theme.greyScale5}`,
  width: '17rem',
  borderRadius: '4px',
  outline: 'none',
  transition: 'all 0.2s ease',
  marginTop: -10,
  marginBottom: -10,
  ':focus': {
    borderColor: 'rgb(18, 141, 219) !important',
    boxShadow: '0px 0px 22px 0px rgba(18, 147, 219, 0.75)',
  },
});

const TYPE_PATHS_MAP = {
  annotation: '/annotations',
  case: '/cases',
  file: '/files',
  gene_centric: '/genes',
  occurrence: '/occurrence',
  project: '/projects',
  report: '/report',
  ssm_centric: '/ssms',
};

const getPreviousItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) - 1) : _.last(items));
const getNextItem = (items, reference) => (reference ? _.nth(items, items.indexOf(reference) + 1) : _.first(items));

let timeOfMostRecentRequest;

export default
compose(
  withState('state', 'setState', {
    results: [],
    selectedResult: null,
    query: '',
    isLoading: false,
    isInSearchMode: false,
  }),
  withRouter,
  withHandlers({
    handleQueryChange: ({ api = API, setState }) => _.debounce(async (q) => {
      const query = q.trim();
      if (!query) {
        setState(s => ({ ...s, isInSearchMode: false, query: '' }));
        return;
      }
      setState(s => ({ ...s, query: s.query ? s.query : query, isLoading: true }));
      const timeOfCurrentRequest = new Date().getTime();
      timeOfMostRecentRequest = timeOfCurrentRequest;
      const { data } = await fetchApi(`/all?fields=${SEARCH_FIELDS.join(',')}&query=${window.encodeURIComponent(query)}&size=5`);
      // prevent results that come back out-of-order from being displayed
      if (timeOfMostRecentRequest === timeOfCurrentRequest) {
        setState(s => ({ ...s, results: data.query.hits, query, isLoading: false }));
      }
    }, 350),
    handleReset: ({ setState }) => () => {
      setState(s => ({ ...s, isInSearchMode: false, query: '' }));
    },
  }),
  withHandlers({
    handleSelectResult: ({ setState }) => (selectedResult: TSearchHit) => setState(s => ({ ...s, selectedResult })),
    handleActivateResult: ({ push, handleReset }) => (result: TSearchHit) => {
      handleReset();
      push(`/${atob(result.id).split(':')[0].toLocaleLowerCase()}s/${atob(result.id).split(':')[1]}`);
    },
  }),
  withHandlers({
    handleKeyDown: ({ state, handleSelectResult, handleActivateResult, handleReset }) => (event) => ({
      ArrowUp: () => {
        event.preventDefault();
        if (_.isEmpty(state.results)) return;
        handleSelectResult(getPreviousItem(state.results, state.selectedResult));
      },
      ArrowDown: () => {
        event.preventDefault();
        if (_.isEmpty(state.results)) return;
        handleSelectResult(getNextItem(state.results, state.selectedResult));
      },
      Enter: () => state.selectedResult && handleActivateResult(state.selectedResult),
      Escape: () => handleReset(),
    }[event.key] || _.noop)(),
  })
)(({
  state,
  setState,
  handleQueryChange,
  handleKeyDown,
  handleSelectResult,
  handleActivateResult,
  handleReset,
  tabIndex,
  style,
}) => (
  <a
    tabIndex={tabIndex}
    onClick={() => !state.isInSearchMode && setState({ isInSearchMode: true })}
    onBlur={(event) => {
      const currentTarget = event.currentTarget;
      const relatedTarget = event.relatedTarget;
      // defer 1 frame to get correct value of document.activeElement, which is required for x-browser compat
      setImmediate(() => {
        const triggerElement = relatedTarget || document.activeElement;
        if (!currentTarget.contains(triggerElement)) {
          handleReset();
        }
      });
    }}
    style={{
      ...style,
      ...styles.container,
    }}
  >
    <span style={styles.searchIconWrapper}>
      <i className="fa fa-search stock-icon" style={Object.assign({}, styles.searchIcon, state.isLoading ? styles.invisible : styles.visible)} />
      <i className="fa fa-spin fa-spinner stock-icon" style={Object.assign({}, styles.loadingIcon, state.isLoading ? styles.visible : styles.invisible)} />
    </span>
    { !state.isInSearchMode && <span className="hidden-md hidden-sm" data-translate>Quick Search</span> }

    {
      state.isInSearchMode &&
      <SearchInput
        autoFocus
        placeholder="Quick Search"
        type="text"
        onChange={event => handleQueryChange(event.target.value)}
        onKeyDown={handleKeyDown}
      />
    }
    {
      state.isInSearchMode && state.query && (
        <QuickSearchResults
          results={_.map(state.results, item =>
            (item === state.selectedResult ? { ...item, isSelected: true } : item)
          )}
          query={state.query}
          onSelectItem={handleSelectResult}
          onActivateItem={handleActivateResult}
          isLoading={state.isLoading}
        />
      )
    }
  </a>
));
